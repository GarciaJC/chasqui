"""Automatic job submission engine for PBS queue management"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../05_agent.ipynb.

# %% auto 0
__all__ = ['AGENT_SCRIPT', 'generate_agent_script', 'deploy_agent', 'trigger_agent', 'parse_agent_log']

# %% ../05_agent.ipynb 3
from pathlib import Path
from typing import Optional
from string import Template

# %% ../05_agent.ipynb 5
AGENT_SCRIPT = """#!/bin/bash
# Chasqui Agent: Automatic PBS job submission
# This script submits waiting jobs when PBS queue has capacity

set -e  # Exit on error

# Configuration
CHASQUI_DIR="${CHASQUI_DIR:-$$HOME/chasqui_remote}"
WAITING_DIR="$$CHASQUI_DIR/waiting"
SUBMITTED_DIR="$$CHASQUI_DIR/submitted"
COMPLETED_DIR="$$CHASQUI_DIR/completed"
LOG_FILE="$$CHASQUI_DIR/logs/agent.log"

# Queue limits (adjust these for your cluster)
MAX_QUEUED=$MAX_QUEUED
MAX_RUNNING=$MAX_RUNNING
MAX_TOTAL=$$((MAX_QUEUED + MAX_RUNNING))

# Ensure directories exist
mkdir -p "$$WAITING_DIR" "$$SUBMITTED_DIR" "$$COMPLETED_DIR" "$$CHASQUI_DIR/logs"

# Logging function
log_message() {
    echo "$$(date -Iseconds) $$1" >> "$$LOG_FILE"
}

# Start of agent run
log_message "AGENT_START"

# Count current PBS jobs
QUEUED=$$(qstat -u $$USER 2>/dev/null | grep " Q " | wc -l || echo 0)
RUNNING=$$(qstat -u $$USER 2>/dev/null | grep " R " | wc -l || echo 0)
TOTAL=$$((QUEUED + RUNNING))

log_message "AGENT_CHECK queued=$$QUEUED running=$$RUNNING total=$$TOTAL"

# Check if we're at capacity
if [ $$TOTAL -ge $$MAX_TOTAL ]; then
    log_message "AGENT_AT_LIMIT total=$$TOTAL max=$$MAX_TOTAL"
    log_message "AGENT_END submitted=0"
    exit 0
fi

# Calculate available slots
SLOTS=$$((MAX_TOTAL - TOTAL))
log_message "AGENT_SLOTS available=$$SLOTS"

# Count waiting jobs
WAITING_COUNT=$$(ls "$$WAITING_DIR"/*.sh 2>/dev/null | wc -l || echo 0)
if [ $$WAITING_COUNT -eq 0 ]; then
    log_message "AGENT_NO_WAITING"
    log_message "AGENT_END submitted=0"
    exit 0
fi

log_message "AGENT_FOUND_WAITING count=$$WAITING_COUNT"

# Submit jobs (up to available slots)
SUBMITTED_COUNT=0
for job_script in $$(ls "$$WAITING_DIR"/*.sh 2>/dev/null | head -n $$SLOTS); do
    JOB_NAME=$$(basename "$$job_script" .sh)
    
    # Submit to PBS
    PBS_OUTPUT=$$(qsub "$$job_script" 2>&1)
    QSUB_EXIT=$$?
    
    if [ $$QSUB_EXIT -eq 0 ]; then
        # Extract PBS job ID (format: 123456.hostname)
        PBS_ID=$$(echo "$$PBS_OUTPUT" | tr -d '\\n')
        
        log_message "AGENT_SUBMIT job=$$JOB_NAME pbs_id=$$PBS_ID status=success"
        
        # Move script to submitted directory
        mv "$$job_script" "$$SUBMITTED_DIR/"
        
        SUBMITTED_COUNT=$$((SUBMITTED_COUNT + 1))
    else
        # Submission failed
        log_message "AGENT_SUBMIT job=$$JOB_NAME status=failed error=$$PBS_OUTPUT"
    fi
done

log_message "AGENT_END submitted=$$SUBMITTED_COUNT"

exit 0
"""

# %% ../05_agent.ipynb 7
def generate_agent_script(
    chasqui_remote_dir: str = "$HOME/chasqui_remote",
    max_queued: int = 40,
    max_running: int = 30,
    output_path: Optional[str] = None
) -> str:
    """
    Generate the remote agent bash script.
    
    Args:
        chasqui_remote_dir: Remote chasqui directory (default: "$HOME/chasqui_remote")
        max_queued: Maximum queued jobs allowed (default: 40)
        max_running: Maximum running jobs allowed (default: 30)
        output_path: If provided, write script to this file
        
    Returns:
        Agent script content as string
        
    Example:
        >>> script = generate_agent_script(
        ...     max_queued=50,
        ...     max_running=20
        ... )
        >>> print(script[:100])
        #!/bin/bash
        # Chasqui Agent: Automatic PBS job submission
    """
    template = Template(AGENT_SCRIPT)
    script = template.safe_substitute(
        CHASQUI_DIR=chasqui_remote_dir,
        MAX_QUEUED=max_queued,
        MAX_RUNNING=max_running
    )
    
    # Write to file if requested
    if output_path:
        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)
        output_file.write_text(script)
        # Make executable
        output_file.chmod(0o755)
    
    return script

# %% ../05_agent.ipynb 9
def deploy_agent(
    ssh_connection,
    chasqui_remote_dir: str = "$HOME/chasqui_remote",
    max_queued: int = 40,
    max_running: int = 30
) -> str:
    """
    Deploy agent script to remote system.
    
    Args:
        ssh_connection: Active SSHConnection object
        chasqui_remote_dir: Remote chasqui directory
        max_queued: Maximum queued jobs allowed
        max_running: Maximum running jobs allowed
        
    Returns:
        Remote path where agent was deployed
        
    Example:
        >>> from chasqui.ssh import SSHConnection
        >>> from chasqui.agent import deploy_agent
        >>> with SSHConnection('bebop') as ssh:
        ...     path = deploy_agent(ssh, max_queued=50)
        ...     print(f"Agent deployed to: {path}")
    """
    import tempfile
    import os
    
    # Generate script
    script = generate_agent_script(
        chasqui_remote_dir=chasqui_remote_dir,
        max_queued=max_queued,
        max_running=max_running
    )
    
    # Create temporary local file
    with tempfile.NamedTemporaryFile(mode='w', suffix='.sh', delete=False) as tmp:
        tmp.write(script)
        tmp_path = tmp.name
    
    try:
        # Expand remote path
        remote_path_expanded = ssh_connection.run(
            f'echo {chasqui_remote_dir}/agent.sh'
        ).strip()
        
        # Upload
        ssh_connection.upload(tmp_path, remote_path_expanded)
        
        # Make executable
        ssh_connection.run(f'chmod +x {remote_path_expanded}')
        
        return remote_path_expanded
        
    finally:
        os.unlink(tmp_path)

# %% ../05_agent.ipynb 11
def trigger_agent(
    ssh_connection,
    chasqui_remote_dir: str = "~/chasqui_remote"
) -> str:
    """
    Manually trigger the agent to submit waiting jobs.
    
    Args:
        ssh_connection: Active SSHConnection object
        chasqui_remote_dir: Remote chasqui directory
        
    Returns:
        Agent log output
        
    Example:
        >>> from chasqui.ssh import SSHConnection
        >>> from chasqui.agent import trigger_agent
        >>> with SSHConnection('bebop') as ssh:
        ...     output = trigger_agent(ssh)
        ...     print(output)
    """
    # Expand path
    agent_path = ssh_connection.run(
        f'echo {chasqui_remote_dir}/agent.sh'
    ).strip()
    
    # Run agent (with flock to prevent conflicts)
    lock_path = f"{chasqui_remote_dir}/agent.lock"
    command = f'flock -n {lock_path} bash {agent_path}'
    
    try:
        result = ssh_connection.run(command)
        return result
    except Exception as e:
        # Agent might already be running (flock fails)
        return f"Agent trigger failed (may already be running): {e}"

# %% ../05_agent.ipynb 13
def parse_agent_log(log_content: str) -> list:
    """
    Parse agent log entries.
    
    Args:
        log_content: Raw agent.log content
        
    Returns:
        List of log entry dictionaries
        
    Example:
        >>> log = '''
        ... 2025-11-01T10:00:00Z AGENT_SUBMIT job=abc-123 pbs_id=12345.bebop status=success
        ... 2025-11-01T10:00:01Z AGENT_END submitted=1
        ... '''
        >>> entries = parse_agent_log(log)
        >>> len(entries)
        2
    """
    entries = []
    
    for line in log_content.strip().split('\n'):
        if not line.strip():
            continue
            
        # Parse format: TIMESTAMP ACTION key=value key=value ...
        parts = line.split(' ', 2)
        if len(parts) < 2:
            continue
            
        timestamp = parts[0]
        action = parts[1]
        
        entry = {
            'timestamp': timestamp,
            'action': action,
            'raw': line
        }
        
        # Parse key=value pairs
        if len(parts) > 2:
            pairs = parts[2].split()
            for pair in pairs:
                if '=' in pair:
                    key, value = pair.split('=', 1)
                    entry[key] = value
        
        entries.append(entry)
    
    return entries
