"""Retrieve VASP calculation outputs from completed jobs on remote HPC systems"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../06_download.ipynb.

# %% auto 0
__all__ = ['DEFAULT_VASP_OUTPUTS', 'OPTIONAL_VASP_OUTPUTS', 'download_job_results', 'download_completed_jobs', 'download_results']

# %% ../06_download.ipynb 3
from pathlib import Path
from typing import List, Dict, Any, Optional
from datetime import datetime

from .database import ChasquiDB
from .ssh import SSHConnection

# %% ../06_download.ipynb 4
# Default files to download for VASP calculations
DEFAULT_VASP_OUTPUTS = [
    'OUTCAR',
    'CONTCAR', 
    'OSZICAR',
    'vasprun.xml'
]

# Optional large files (user can include if needed)
OPTIONAL_VASP_OUTPUTS = [
    'CHGCAR',
    'WAVECAR',
    'CHG',
    'PROCAR',
    'DOSCAR',
    'EIGENVAL'
]

def download_job_results(
    ssh: SSHConnection,
    job: Dict[str, Any],
    file_list: Optional[List[str]] = None,
    skip_missing: bool = True
) -> Dict[str, Any]:
    """
    Download VASP output files for a single job.
    
    Args:
        ssh: Active SSH connection
        job: Job dictionary from database (must have 'remote_path' and 'local_path')
        file_list: List of filenames to download (default: DEFAULT_VASP_OUTPUTS)
        skip_missing: If True, skip files that don't exist on remote (default: True)
        
    Returns:
        Dictionary with download statistics:
            - 'downloaded': List of successfully downloaded files
            - 'skipped': List of missing files (if skip_missing=True)
            - 'failed': List of files that failed to download
    
    Example:
        >>> with SSHConnection('user@bebop') as ssh:
        ...     result = download_job_results(ssh, job)
        ...     print(f"Downloaded {len(result['downloaded'])} files")
    """
    if file_list is None:
        file_list = DEFAULT_VASP_OUTPUTS
    
    local_path = Path(job['local_path']).expanduser()
    remote_path = job.get('remote_path')
    
    if not remote_path:
        raise ValueError(f"Job {job['job_id']} has no remote_path set")
    
    # Ensure local directory exists
    local_path.mkdir(parents=True, exist_ok=True)
    
    result = {
        'downloaded': [],
        'skipped': [],
        'failed': []
    }
    
    for filename in file_list:
        remote_file = f"{remote_path}/{filename}"
        local_file = local_path / filename
        
        try:
            # Check if file exists on remote
            if not ssh.exists(remote_file):
                if skip_missing:
                    result['skipped'].append(filename)
                    continue
                else:
                    raise FileNotFoundError(f"Remote file not found: {remote_file}")
            
            # Download the file
            ssh.download(remote_file, local_file, create_dirs=False)
            result['downloaded'].append(filename)
            
        except FileNotFoundError:
            if skip_missing:
                result['skipped'].append(filename)
            else:
                result['failed'].append(filename)
        except Exception as e:
            result['failed'].append(filename)
            print(f"Warning: Failed to download {filename}: {e}")
    
    return result

# %% ../06_download.ipynb 6
def download_completed_jobs(
    db: ChasquiDB,
    ssh: SSHConnection,
    file_list: Optional[List[str]] = None,
    limit: Optional[int] = None,
    update_db: bool = True
) -> Dict[str, Any]:
    """
    Download results for all completed jobs that haven't been downloaded yet.
    
    Args:
        db: Database connection
        ssh: Active SSH connection
        file_list: List of files to download (default: DEFAULT_VASP_OUTPUTS)
        limit: Maximum number of jobs to process (None = all)
        update_db: Update database with download timestamp (default: True)
        
    Returns:
        Dictionary with statistics:
            - 'jobs_processed': Number of jobs processed
            - 'total_downloaded': Total files downloaded
            - 'total_skipped': Total files skipped
            - 'total_failed': Total files that failed
            - 'jobs': List of per-job results
    
    Example:
        >>> db = ChasquiDB()
        >>> with SSHConnection('user@bebop') as ssh:
        ...     result = download_completed_jobs(db, ssh, limit=10)
        ...     print(f"Processed {result['jobs_processed']} jobs")
    """
    # Query completed jobs without download timestamp
    completed_jobs = db.get_jobs_by_state('COMPLETED')
    
    # Filter to jobs that haven't been downloaded yet
    # (jobs without downloaded_at timestamp)
    pending_downloads = [
        job for job in completed_jobs 
        if job.get('downloaded_at') is None
    ]
    
    if limit:
        pending_downloads = pending_downloads[:limit]
    
    stats = {
        'jobs_processed': 0,
        'total_downloaded': 0,
        'total_skipped': 0,
        'total_failed': 0,
        'jobs': []
    }
    
    for job in pending_downloads:
        job_id = job['job_id']
        
        try:
            # Download files for this job
            result = download_job_results(ssh, job, file_list=file_list)
            
            # Update statistics
            stats['jobs_processed'] += 1
            stats['total_downloaded'] += len(result['downloaded'])
            stats['total_skipped'] += len(result['skipped'])
            stats['total_failed'] += len(result['failed'])
            
            # Store per-job result
            stats['jobs'].append({
                'job_id': job_id,
                'result': result
            })
            
            # Update database if requested
            if update_db and len(result['downloaded']) > 0:
                db.update_state(
                    job_id,
                    'COMPLETED',  # Keep same state
                    downloaded_at=datetime.now().isoformat()
                )
                
        except Exception as e:
            print(f"Warning: Failed to download results for job {job_id}: {e}")
            stats['jobs'].append({
                'job_id': job_id,
                'error': str(e)
            })
    
    return stats

# %% ../06_download.ipynb 9
def download_results(
    remote_host: str,
    db_path: str = "~/.chasqui/jobs.db",
    file_list: Optional[List[str]] = None,
    limit: Optional[int] = None,
    include_optional: bool = False
) -> Dict[str, Any]:
    """
    Download results for completed jobs (convenience wrapper).
    
    Args:
        remote_host: SSH hostname (e.g., 'bebop' or 'user@hpc.edu')
        db_path: Path to chasqui database
        file_list: Custom list of files to download (overrides defaults)
        limit: Maximum number of jobs to download (None = all)
        include_optional: Include large optional files (CHGCAR, WAVECAR)
        
    Returns:
        Dictionary with download statistics
        
    Example:
        >>> # Download standard outputs for all completed jobs
        >>> result = download_results('bebop')
        >>> print(f"Downloaded {result['total_downloaded']} files")
        
        >>> # Download including large files, limit to 5 jobs
        >>> result = download_results('bebop', include_optional=True, limit=5)
    """
    # Build file list
    if file_list is None:
        file_list = DEFAULT_VASP_OUTPUTS.copy()
        if include_optional:
            file_list.extend(OPTIONAL_VASP_OUTPUTS)
    
    # Initialize database
    db = ChasquiDB(db_path)
    
    # Connect and download
    with SSHConnection(remote_host) as ssh:
        result = download_completed_jobs(
            db, 
            ssh, 
            file_list=file_list, 
            limit=limit
        )
    
    return result
