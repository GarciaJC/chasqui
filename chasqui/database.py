"""Local job queue database for chasqui workflow automation"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../02_database.ipynb.

# %% auto 0
__all__ = ['SCHEMA_SQL', 'ChasquiDB']

# %% ../02_database.ipynb 3
import sqlite3
from pathlib import Path
from datetime import datetime
from typing import Optional, List, Dict, Any, Tuple
from contextlib import contextmanager
import json
import uuid
from fastcore.basics import patch

# %% ../02_database.ipynb 5
SCHEMA_SQL = """
-- Jobs table: tracks all jobs through their lifecycle
CREATE TABLE IF NOT EXISTS jobs (
    job_id TEXT PRIMARY KEY,
    state TEXT NOT NULL CHECK(state IN (
        'PREPARED', 'QUEUED_LOCAL', 'UPLOADED', 
        'SUBMITTED', 'RUNNING', 'COMPLETED', 'FAILED'
    )),
    
    -- Timestamps
    created_at TEXT NOT NULL,
    queued_at TEXT,
    uploaded_at TEXT,
    submitted_at TEXT,
    completed_at TEXT,
    downloaded_at TEXT,  
    
    -- Local information
    local_path TEXT NOT NULL,
    vasp_config TEXT,  -- JSON blob with VASP parameters
    
    -- Remote information
    remote_path TEXT,
    pbs_id TEXT,  -- PBS job ID (null until submitted)
    
    -- Sync tracking
    last_synced TEXT,
    downloaded INTEGER DEFAULT 0  -- Boolean: results downloaded?
);

-- Index for common queries
CREATE INDEX IF NOT EXISTS idx_jobs_state ON jobs(state);
CREATE INDEX IF NOT EXISTS idx_jobs_pbs_id ON jobs(pbs_id);

-- Sync log: audit trail of all sync operations
CREATE TABLE IF NOT EXISTS sync_log (
    sync_id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp TEXT NOT NULL,
    uploaded INTEGER DEFAULT 0,
    submitted INTEGER DEFAULT 0,
    completed INTEGER DEFAULT 0,
    failed INTEGER DEFAULT 0,
    downloaded INTEGER DEFAULT 0,
    details TEXT  -- JSON blob with additional info
);

-- Schema version tracking
CREATE TABLE IF NOT EXISTS schema_version (
    version INTEGER PRIMARY KEY,
    applied_at TEXT NOT NULL
);

INSERT OR IGNORE INTO schema_version (version, applied_at)
VALUES (1, datetime('now'));
"""

# %% ../02_database.ipynb 7
class ChasquiDB:
    """
    SQLite database manager for chasqui job tracking.
    
    Example:
        >>> db = ChasquiDB("~/.chasqui/jobs.db")
        >>> db.init_db()
        >>> job_id = db.create_job(local_path="/path/to/job")
    """
    
    def __init__(self, db_path: str = "~/.chasqui/jobs.db"):
        """
        Initialize database connection.
        
        Args:
            db_path: Path to SQLite database file
        """
        self.db_path = Path(db_path).expanduser()
        self.db_path.parent.mkdir(parents=True, exist_ok=True)

# %% ../02_database.ipynb 9
@patch
@contextmanager
def _connect(self: ChasquiDB):
    """Context manager for database connections."""
    conn = sqlite3.connect(self.db_path)
    conn.row_factory = sqlite3.Row  # Access columns by name
    try:
        yield conn
        conn.commit()
    except Exception as e:
        conn.rollback()
        raise e
    finally:
        conn.close()

@patch
def init_db(self: ChasquiDB):
    """Initialize database schema."""
    with self._connect() as conn:
        conn.executescript(SCHEMA_SQL)

# %% ../02_database.ipynb 11
@patch
def create_job(
    self: ChasquiDB,
    local_path: str,
    vasp_config: Optional[Dict[str, Any]] = None
) -> str:
    """
    Create a new job in PREPARED state.
    
    Args:
        local_path: Path to local directory with VASP inputs
        vasp_config: Dictionary with VASP parameters (optional)
        
    Returns:
        job_id: UUID for the created job
        
    Example:
        >>> db = ChasquiDB()
        >>> job_id = db.create_job(
        ...     local_path="/scratch/vasp_job_001",
        ...     vasp_config={"encut": 500, "kpoints": [4,4,4]}
        ... )
    """
    job_id = str(uuid.uuid4())
    now = datetime.now().isoformat()
    
    with self._connect() as conn:
        conn.execute("""
            INSERT INTO jobs (job_id, state, created_at, local_path, vasp_config)
            VALUES (?, ?, ?, ?, ?)
        """, (
            job_id,
            'PREPARED',
            now,
            local_path,
            json.dumps(vasp_config) if vasp_config else None
        ))
    
    return job_id

# %% ../02_database.ipynb 13
@patch
def update_state(
    self: ChasquiDB,
    job_id: str,
    new_state: str,
    **kwargs
):
    """
    Update job state and related fields.
    
    Args:
        job_id: Job UUID
        new_state: New state value
        **kwargs: Additional fields to update (e.g., pbs_id, remote_path)
        
    Example:
        >>> db.update_state("abc-123", "SUBMITTED", pbs_id="12345678")
    """
    # Build UPDATE statement dynamically
    timestamp_field = {
        'QUEUED_LOCAL': 'queued_at',
        'UPLOADED': 'uploaded_at',
        'SUBMITTED': 'submitted_at',
        'COMPLETED': 'completed_at',
        'FAILED': 'completed_at'
    }.get(new_state)
    
    updates = {'state': new_state}
    if timestamp_field:
        updates[timestamp_field] = datetime.now().isoformat()
    updates.update(kwargs)
    
    # Build SQL
    set_clause = ', '.join(f"{k} = ?" for k in updates.keys())
    values = list(updates.values()) + [job_id]
    
    with self._connect() as conn:
        conn.execute(
            f"UPDATE jobs SET {set_clause} WHERE job_id = ?",
            values
        )

# %% ../02_database.ipynb 15
@patch
def get_job(self: ChasquiDB, job_id: str) -> Optional[Dict[str, Any]]:
    """Get job by ID."""
    with self._connect() as conn:
        row = conn.execute(
            "SELECT * FROM jobs WHERE job_id = ?",
            (job_id,)
        ).fetchone()
        return dict(row) if row else None

@patch
def get_jobs_by_state(self: ChasquiDB, state: str) -> List[Dict[str, Any]]:
    """Get all jobs in a given state."""
    with self._connect() as conn:
        rows = conn.execute(
            "SELECT * FROM jobs WHERE state = ?",
            (state,)
        ).fetchall()
        return [dict(row) for row in rows]

@patch
def get_all_jobs(self: ChasquiDB) -> List[Dict[str, Any]]:
    """Get all jobs."""
    with self._connect() as conn:
        rows = conn.execute("SELECT * FROM jobs ORDER BY created_at").fetchall()
        return [dict(row) for row in rows]

# %% ../02_database.ipynb 17
@patch
def log_sync(
    self: ChasquiDB,
    uploaded: int = 0,
    submitted: int = 0,
    completed: int = 0,
    failed: int = 0,
    downloaded: int = 0,  # ADD THIS PARAMETER
    details: Optional[Dict[str, Any]] = None
):
    """
    Record a sync operation.
    
    Args:
        uploaded: Number of jobs uploaded
        submitted: Number of jobs submitted to PBS
        completed: Number of jobs completed
        failed: Number of jobs failed
        downloaded: Number of files downloaded  # ADD THIS LINE
        details: Additional information (optional)
    """
    now = datetime.now().isoformat()
    
    with self._connect() as conn:
        conn.execute("""
            INSERT INTO sync_log 
            (timestamp, uploaded, submitted, completed, failed, downloaded, details)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        """, (
            now,
            uploaded,
            submitted,
            completed,
            failed,
            downloaded,  # ADD THIS VALUE
            json.dumps(details) if details else None
        ))

@patch
def get_last_sync(self: ChasquiDB) -> Optional[Dict[str, Any]]:
    """Get the most recent sync operation."""
    with self._connect() as conn:
        row = conn.execute(
            "SELECT * FROM sync_log ORDER BY sync_id DESC LIMIT 1"
        ).fetchone()
        return dict(row) if row else None
